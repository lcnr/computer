start:
    mov 12 C;
    mov 5 D;
    # push the return addr of the stack
    mov 1 M2;
    mov 0 M1;
    mov MEM A;
    mov A M1;
    mov start;
    mov 1 B;
    add A;
    mov A M1;
    store .next_pos;
    add A;
    mov 0 M1;
    mov A;
.next_pos:
    # the result should now be in A
    jmp .next_pos;


# calculate C * D, storing the result in C
multiply:
    mov 0 B;
.loop:
    mov C A;
    mov B C;
    if z jmp .end;
    mov 1 B;
    sub A;
    mov C B;
    mov A C;
    mov D A;
    add B;
    jmp .loop;
.end:
    # pop the return addr from the stack, jump back
    mov 1 M2;
    mov 0 M1;
    mov MEM A;
    mov 1 B;
    sub A;
    mov A M1;
    mov MEM D;
    sub A;
    mov A M1;
    mov MEM B;
    mov 0 M1; # update stack pointer
    mov A;
    mov D A;
    mov MEM A;
    ret B A;


