# Micro Commands

Notes:

- To update a register, Update IR has to be `0b01`.

0. Increment P
1. Bus Input
2. Bus Input
3. Bus Input
---
4. Select Register (to update)
5. Select Register (to update)
6. Update RAM
7. RAM select M (default P)
---
8. ALU
9. ALU
10. ALU
11. ALU
---
12. Update Accu
13. Accu select Bus (default ALU)
14. Update IR
15. Update IR

|           | ALU           | Bus Input | Update IR     | Select Register   |
| --------- | ------------- | --------- | ------------- | ----------------- |
| `0b0000`  | Accu & Bus    | RAM       | don't         | M1                |
| `0b0001`  | Bus \| Accu   | Accu      | UPDATE REG    | M2                |
| `0b0010`  | Accu ^ Bus    | ALU       | if Carry == 1 | P1                |
| `0b0011`  | Accu + Bus    | Zero      | if ALU == 0   | P2, sets P1 to 0  |
| `0b0100`  | Accu - Bus    | M1        | -             | -                 |
| `0b0101`  | Bus - Accu    | M2        | -             | -                 |
| `0b0110`  | -             | P1        | -             | -                 |
| `0b0111`  | -             | P2        | -             | -                 |
| `0b1000`  | Accu << Bus   | -         | -             | -                 |
| `0b1001`  | Bus << Accu   | -         | -             | -                 |
| `0b1010`  | Accu >> Bus   | -         | -             | -                 |
| `0b1011`  | Bus >> Accu   | -         | -             | -                 |
| `0b1100`  | Accu          | -         | -             | -                 |
| `0b1101`  | Bus           | -         | -             | -                 |
| `0b1110`  | !Accu         | -         | -             | -                 |
| `0b1111`  | !Bus          | -         | -             | -                 |

# Commands

*steps are stored in RAM with the order 1, 2, 4, 3 to prevent timing errors. (Huffman code 00 01 11 10)*

| Opcode     | Name     | Function                                                      |
| ---------- | -------- | ------------------------------------------------------------- |
| `0x00`     | idle     | do nothing/simply increment PC by 1                           |
| `0x01`     | addc     | Accu = Accu + mem[PC + 1]; PC += 2;                           |
| `0x02`     | addm     | Accu = Accu + mem[MR]; PC += 1;                               |
| `0x03`     | subc     | Accu = Accu - mem[PC + 1]; PC += 2;                           |
| `0x04`     | subm     | Accu = Accu - mem[MR]; PC += 1;                               |
| `0x05`     | shlc     | Accu = Accu << mem[PC + 1]; PC += 2;                          |
| `0x06`     | shlm     | Accu = Accu << mem[MR]; PC += 1;                              |
| `0x07`     | shrc     | Accu = Accu >> mem[PC + 1]; PC += 2;                          |
| `0x08`     | shrm     | Accu = Accu >> mem[MR]; PC += 1;                              |
| `0x09`     | andc     | Accu = Accu & mem[PC + 1]; PC += 2;                           |
| `0x0a`     | andm     | Accu = Accu & mem[MR]; PC += 1;                               |
| `0x0b`     | orc      | Accu = Accu \| mem[PC + 1]; PC += 2;                          |
| `0x0c`     | orm      | Accu = Accu \| mem[MR]; PC += 1;                              |
| `0x0d`     | xorc     | Accu = Accu ^ mem[PC + 1]; PC += 2;                           |
| `0x0e`     | xorm     | Accu = Accu ^ mem[MR]; PC += 1;                               |
| `0x0f`     | inv      | Accu = !Accu; PC += 1;                                        |
| `0x10`     | loadc    | Accu = mem[PC + 1]; PC += 2;                                  |
| `0x11`     | loadm    | Accu = mem[MR]; PC += 1;                                      |
| `0x12`     | store    | mem[MR] = Accu; PC += 1;                                      |
| `0x13`     | zero     | Accu = 0; PC += 1;                                            |
| `0x14`     | setsc    | M1 = mem[PC + 1]; PC += 2;                                    |
| `0x15`     | setsa    | M1 = Accu; PC += 1;                                           |
| `0x16`     | setbc    | M2 = mem[PC + 1]; PC += 2;                                    |
| `0x17`     | setba    | M2 = Accu; PC += 1;                                           |
| `0x18`     | gets     | Accu = M1; PC += 1;                                           |
| `0x19`     | getb     | Accu = M2; PC += 1;                                           |
| `0x1a`     | jmpc     | P1 = mem[PC + 1];                                             |
| `0x1b`     | jmpm     | P1 = mem[MR];                                                 |
| `0x1c`     | jmpa     | P1 = Accu;                                                    |
| `0x1d`     | ljmpc    | P1 = 0; P2 = mem[PC + 1];                                     |
| `0x1e`     | ljmpm    | P1 = 0; P2 = mem[MR];                                         |
| `0x1f`     | ljmpa    | P1 = 0; P2 = Accu;                                            |
| `0x2021`   | jmpzc    | if Accu == 0 { P1 = mem[PC + 2] } else { PC += 3 };           |
| `0x2120`   | jmpnzc   | if Accu != 0 { P1 = mem[PC + 2] } else { PC += 3 };           |
| `0x2223`   | jmpzm    | if Accu == 0 { P1 = mem[MR] } else { PC += 2 };               |
| `0x2322`   | jmpnzm   | if Accu != 0 { P1 = mem[MR] } else { PC += 2 };               |
| `0x2425`   | ljmpzc   | if Accu == 0 { P1 = 0; P2 = mem[PC + 1] } else { PC += 3 };   |
| `0x2524`   | ljmpnzc  | if Accu != 0 { P1 = 0; P2 = mem[PC + 1] } else { PC += 3 };   |
| `0x2627`   | ljmpzm   | if Accu == 0 { P1 = 0; P2 = mem[MR] } else { PC += 2 };       |
| `0x2726`   | ljmpnzm  | if Accu != 0 { P1 = 0; P2 = mem[MR] } else { PC += 2 };       |
| `0x28xx29` | jmpgtcc  | if Accu > mem[PC + 1] { P1 = mem[PC + 3] } else { PC += 4}    |
| `0x29xx28` | jmpltecc | if Accu <= mem[PC + 1] { P1 = mem[PC + 3] } else { PC += 4}   |
| `0x2axx2b` | jmpltcc  | if Accu < mem[PC + 1] { P1 = mem[PC + 3] } else { PC += 4}    |
| `0x2bxx2a` | jmpgtecc | if Accu >= mem[PC + 1] { P1 = mem[PC + 3] } else { PC += 4}   |
| `0x2cxx2d` | jmpeqcc  | if Accu == mem[PC + 1] { P1 = mem[PC + 3] } else { PC += 4}   |
| `0x2dxx2c` | jmpneqcc | if Accu != mem[PC + 1] { P1 = mem[PC + 3] } else { PC += 4}   |
| `0x2exx2f` | jmpgtcm  | if Accu > mem[PC + 1] { P1 = mem[MR] } else { PC += 3}        |
| `0x2fxx3e` | jmpltecm | if Accu <= mem[PC + 1] { P1 = mem[MR] } else { PC += 3}       |
| `0x30xx31` | jmpltcm  | if Accu < mem[PC + 1] { P1 = mem[MR] } else { PC += 3}        |
| `0x31xx30` | jmpgtecm | if Accu >= mem[PC + 1] { P1 = mem[MR] } else { PC += 3}       |
| `0x32xx33` | jmpeqcm  | if Accu == mem[PC + 1] { P1 = mem[MR] } else { PC += 3}       |
| `0x33xx32` | jmpneqcm | if Accu != mem[PC + 1] { P1 = mem[MR] } else { PC += 3}       |
| `0x3435`   | jmpgtmc  | if Accu > mem[MR] { P1 = mem[PC + 2] } else { PC += 3}        |
| `0x3534`   | jmpltemc | if Accu <= mem[MR] { P1 = mem[PC + 2] } else { PC += 3}       |
| `0x3637`   | jmpltmc  | if Accu < mem[MR] { P1 = mem[PC + 2] } else { PC += 3}        |
| `0x3736`   | jmpgtemc | if Accu >= mem[MR] { P1 = mem[PC + 2] } else { PC += 3}       |
| `0x3839`   | jmpeqmc  | if Accu == mem[MR] { P1 = mem[PC + 2] } else { PC += 3}       |
| `0x3938`   | jmpneqmc | if Accu != mem[MR] { P1 = mem[PC + 2] } else { PC += 3}       |
| `0x3axx3b` | ljmpgtcc  | if Accu > mem[PC + 1] { P1 = 0; P2 = mem[PC + 3] } else { PC += 4} TODO|
| `0x3bxx3a` | ljmpltecc | if Accu <= mem[PC + 1] { P1 = 0; P2 = mem[PC + 3] } else { PC += 4} TODO|
| `0x3cxx3d` | ljmpgtecc | if Accu >= mem[PC + 1] { P1 = 0; P2 = mem[PC + 3] } else { PC += 4} TODO|
| `0x3dxx3c` | ljmpltcc  | if Accu < mem[PC + 1] { P1 = 0; P2 = mem[PC + 3] } else { PC += 4} TODO|
| `0x3exx3f` | ljmpeqcc  | if Accu == mem[PC + 1] { P1 = 0; P2 = mem[PC + 3] } else { PC += 4} TODO|
| `0x3fxx3e` | ljmpneqcc | if Accu != mem[PC + 1] { P1 = 0; P2 = mem[PC + 3] } else { PC += 4} TODO|
| `0x40xx41` | ljmpgtcm  | if Accu > mem[PC + 1] { P1 = 0; P2 = mem[MR] } else { PC += 3} TODO   |
| `0x41xx40` | ljmpltecm | if Accu <= mem[PC + 1] { P1 = 0; P2 = mem[MR] } else { PC += 3} TODO  |
| `0x42xx43` | ljmpgtecm | if Accu >= mem[PC + 1] { P1 = 0; P2 = mem[MR] } else { PC += 3} TODO  |
| `0x43xx42` | ljmpltcm  | if Accu < mem[PC + 1] { P1 = 0; P2 = mem[MR] } else { PC += 3} TODO   |
| `0x44xx45` | ljmpeqcm  | if Accu == mem[PC + 1] { P1 = 0; P2 = mem[MR] } else { PC += 3} TODO  |
| `0x45xx44` | ljmpneqcm | if Accu != mem[PC + 1] { P1 = 0; P2 = mem[MR] } else { PC += 3} TODO  |
| `0x4647`   | ljmpgtmc  | if Accu > mem[MR] { P1 = 0; P2 = mem[PC + 2] } else { PC += 3} TODO   |
| `0x4746`   | ljmpltemc | if Accu <= mem[MR] { P1 = 0; P2 = mem[PC + 2] } else { PC += 3} TODO  |
| `0x4849`   | ljmpgtemc | if Accu >= mem[MR] { P1 = 0; P2 = mem[PC + 2] } else { PC += 3} TODO  |
| `0x4948`   | ljmpltmc  | if Accu < mem[MR] { P1 = 0; P2 = mem[PC + 2] } else { PC += 3} TODO   |
| `0x4a4b`   | ljmpeqmc  | if Accu == mem[MR] { P1 = 0; P2 = mem[PC + 2] } else { PC += 3} TODO  |
| `0x4b4a`   | ljmpneqmc | if Accu != mem[MR] { P1 = 0; P2 = mem[PC + 2] } else { PC += 3} TODO  |
| `0xff`     | reset    | set registers, Accu and PC to 0                               |0 0 1 0 1e00 0 1 0
1 3000 1 0 3080 0 1 0
c2 0 1 0 3003 0 1 0
1 4000 1 0 4002 0 1 0
1 4010 1 0 4012 0 1 0
3008 0 1 0 300a 0 1 0
1 4020 0 0 40a0 0 0 0
4022 0 0 0 1 0 4030 0
0 0 40b0 0 0 0 4032 0
cc01 1 1 0 cc01 1 4020 0
cc01 0 1 0 cc01 0 40a0 0
cc01 1 1 0 cc01 1 4030 0
cc01 0 1 0 cc01 0 40b0 0
1 8501 1 1 1 8501 4020 1
1 8401 1 1 1 8401 4020 1
1 c501 1 1 1 c501 4020 1
1 8501 1 0 1 8501 40a0 0
1 8401 1 0 1 8401 40a0 0
1 c501 1 0 1 c501 40a0 0
8581 1 1 0 8581 1 4020 0
8481 1 1 0 8481 1 4020 0
c581 1 1 0 c581 1 4020 0
1 8501 1 1 1 8501 4030 1
1 8401 1 1 1 8401 4030 1
1 c501 1 1 1 c501 4030 1
1 8501 1 0 1 8501 40b0 1
1 8401 1 0 1 8401 40b0 1
1 c501 1 0 1 c501 40b0 1
740*0 7006 4026 4030
